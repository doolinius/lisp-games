(defun divisible (x y)
  (= (mod x y) 0))

(defun primep (integer list-of-primes)
  (let ((end (the fixnum (position-if #'(lambda (y) 
					  (> y (isqrt integer))) list-of-primes))))
    (notany #'(lambda (x) 
		(divisible integer x)) (subseq list-of-primes 0 end))))

(defun generate-primes-to (x)
  (declare (fixnum x) (optimize (speed 3) (safety 0)))
  (let* ((int-array (make-array x :element-type 'bit :initial-element 0))
	 (primes (list 2))
	 (root-of-x (isqrt x)))
    (declare (fixnum root-of-x))
    (do ((i 3 (the fixnum (+ i 2))))
      ((>= i x) (nreverse primes))
      (declare (fixnum i))
      (progn (when (= (sbit int-array i) 0)
	       (push i primes)
	       (if (< i root-of-x)
		 (do* ((inc (+ i i))
		       (j (* i i) (the fixnum (+ j inc))))
		   ((>= j x))
		   (declare (fixnum j inc))
		   (setf (sbit int-array j) 1))))))))

